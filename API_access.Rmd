---
title: "YouTube API Zugriff mit R"
author: "Tim König"
date: "2023-03-06"
output: 
  ioslides_presentation:
    logo: "D:/academicCloud/EPINETZ/logo-hildesheim-rd_gr_fr.png"
    fig_width: 9
    fig_height: 7
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = "")

library(tidyverse)
library(tuber)
library(lubridate)

party_videos <- readRDS("data/party_videos.RDS")
comments_january <- readRDS("data/comments_january.RDS")

```

## Die YouTube API

```{r, echo=FALSE, fig.cap="https://developers.google.com/static/youtube/images/yt-data-api-search_720.png?hl=de", out.height="100%", out.width="100%"}
knitr::include_graphics("yt-data-api-search_720.png")
```

## Vorteile der YouTube API

**Vorteile gegenüber Webscraping**

-   sauber formatierte, verlässliche Daten
-   legale, durch Terms of Service regulierte Datenbeschaffung
-   gute Dokumentation
-   *keine HTML-Kenntnisse nötig*
-   R-Packages zum Umgang mit der API, z.B. tuber

**Nachteile**

-   Mögliche Daten durch die Endpoints der API vorgegeben
-   Rate Limits reglementieren die täglich verfügbare Datenmenge
-   Authentifizierung via OAuth 2.0 / API Keys etwas umständlich

## Fallbeispiel: Youtube Kanäle der Parteien

```{r, echo=FALSE, fig.cap="", out.width="85%", out.height="85%"}
knitr::include_graphics("party_channels.png")
```

# Die YouTube API mit *R*

## Zugriff auf die YouTube API

```{r, eval=FALSE}
library(tuber)
library(tidyverse)

yt_oauth(
  app_id = "81481321824-btqvdmev607hbbq3n34i4qpb194spdq7.apps.googleusercontent.com",
  app_secret = "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")
```

## YouTube Kanäle der Parteien

```{r}
party_channels <- tibble(
  party = c("cdu",
            "spd",
            "gruene",
            "fdp", 
            "afd", 
            "linke"),
  channel_id = c("UCKyWIEse3u7ExKfAWuDMVnw",
                 "UCSmbK1WtpYn2sOGLvSSXkKw",
                 "UC7TAA2WYlPfb6eDJCeX4u0w",
                 "UC-sMkrfoQDH-xzMxPNckGFw",
                 "UCq2rogaxLtQFrYG3X3KYNww",
                 "UCA95T5bSGxNOAODBdbR2rYQ")
)
```

## Zugriff auf die Kanäle

```{r, eval=FALSE}
party_videos <- tibble() # empty container object to fill

# loop through every row in the dataframe of party channels
for (i in 1:nrow(party_channels)) { 
  # make the API call
  videos <-  list_channel_videos(
    channel_id = party_channels$channel_id[i],
    max_results = Inf)
  # add party indicator
  videos <- videos %>% mutate(party = party_channels$party[i]) 
  # bind results
  party_videos <- bind_rows(party_videos, videos) 
  # some printout to keep track
  cat(party_channels$party[i], ": ", 
      nrow(videos), 
      " videos retrieved \n", 
      sep = "") 
  # a sleep period between calls to avoid API errors
  Sys.sleep(1) 
  
}

```

## Zugriff auf die Kanäle: Resultat

```{r, echo=FALSE}
print(party_videos)
```

```{r}
party_videos <- party_videos %>% # some data cleaning
  mutate(contentDetails.videoPublishedAt = ymd_hms(contentDetails.videoPublishedAt)) %>%  # proper datetime format
  
  distinct(contentDetails.videoId, .keep_all = T) %>% # make sure there are no duplicates
  mutate(party_label = case_when( # add some proper party labels
    party == "afd" ~ "AfD",
    party == "cdu" ~ "CDU",
    party == "spd" ~ "SPD",
    party == "fdp" ~ "FDP",
    party == "gruene" ~ "Bündnis 90/Die Grünen",
    party == "linke" ~ "DIE LINKE"
  ))
```
